#! /usr/bin/env python
# -*- python -*-

from __future__ import print_function
import os
import sys
import argparse
from rootutils.prettytable import PrettyTable

import signal
signal.signal(signal.SIGPIPE, signal.SIG_DFL)

try:
    import ROOT
except ImportError:
    print('Error importing ROOT. Exiting...')
    sys.exit(1)

ROOT.PyConfig.IgnoreCommandLineOptions = True
ROOT.gROOT.SetBatch(True)


# colors
green  = '\033[92m'
red    = '\033[91m'
blue   = '\033[94m'
purple = '\033[95m'
endc   = '\033[0m'


def str_to_num(s):
    try:
        return int(s)
    except ValueError:
        return float(s)



#------------
# Histograms
#------------
def print_hist_all(hist):

    labels = []
    values = []
    for b in xrange(hist.GetNbinsX()):
        label = hist.GetXaxis().GetBinLabel(b+1)
        if not label:
            label = 'bin %.2i' % (b+1)

        labels.append(label)
        values.append((hist.GetBinContent(b+1), hist.GetBinError(b+1)))

    max_len = max([len(label) for label in labels]) + 1
    for label, (val, err) in zip(labels, values):
        print('%s%s: %.2f +- %.2f' % (label, ' '*(max_len-len(label)), val, err))


def print_hist(hist, args):

    if args.getbin is not None:

        if args.getbin == 'last':
            bin_ = hist.GetNbinsX()
        else:
            bin_ = int(args.getbin)

        if bin_ <= hist.GetNbinsX() and bin_ > 0:
            print(hist.GetBinContent(bin_))
        else:
            print('bin %i does not exist.' % bin_)

    else:
        print_hist_all(hist)

#-------
# Trees
#-------
def scan_tree(tree, fields, selection, sort=None):

    # get query
    res = tree.Query(fields, selection)

    nrows = res.GetRowCount()
    nfields = res.GetFieldCount()

    fields = [res.GetFieldName(j) for j in xrange(nfields)]
    rows = []
    for i in xrange(nrows):
        row = res.Next()
        rows.append([str_to_num(row.GetField(j)) for j in xrange(nfields)])


    # build table
    table = PrettyTable(fields)
    for row in rows:
        table.add_row(row)

    table.sortby = sort
    table.align = 'r'

    print(table)


def print_tree(tree, args):

    if args.getentries:
        print(tree.GetEntries())

    elif args.count:

        hist = ROOT.TH1F('count', 'count', 1, 0.5, 1.5)
        tree.Project('count', '1', args.selection)

        error = ROOT.Double(0.0)
        integral = hist.IntegralAndError(1, hist.GetNbinsX(), error)

        print('%.2f +- %.2f' % (integral, error))

    elif args.scan:
        scan_tree(tree, args.scan, args.selection, args.sort)

    else:
        for b in tree.GetListOfLeaves():
            print(b.GetName())



def main():

    parser = argparse.ArgumentParser(description='')

    ## paths
    parser.add_argument('filepath', nargs='?')
    parser.add_argument('rootpath', nargs='?')

    ## general options
    parser.add_argument('--del', dest='delete', action='store_true')
    parser.add_argument('-t', '--type', action='store_true', help='')

    ## tree options
    parser.add_argument('--scan')
    parser.add_argument('--sort')

    parser.add_argument('-ge', '--getentries', action='store_true')
    parser.add_argument('-s', '--selection', default='')
    parser.add_argument('-ce', '--count', action='store_true')

    ## histogram options
    parser.add_argument('-gb', '--getbin')

    if len(sys.argv) < 2:
        parser.print_usage()
        return

    args = parser.parse_args()

    file_path, root_path = args.filepath, args.rootpath

    # dir with root files
    if os.path.isdir(file_path):

        dir_content = [ os.path.join(file_path, fn) for fn in os.listdir(file_path) if '.root' in fn ]

        if len(dir_content) == 0:
            print('directory is empty')
            return 1

        # assume all files in dir have the same tree with this name
        if root_path is not None:

            obj = ROOT.TFile.Open(dir_content[0]).Get(root_path)

            # tree
            if obj.InheritsFrom('TTree'):

                chain = ROOT.TChain(root_path)

                for fn in dir_content:
                    chain.Add(fn)

                print_tree(chain, args)

            # histogram
            elif obj.InheritsFrom('TH1'):

                hist = obj.Clone()

                for fn in dir_content[1:]:

                    f = ROOT.TFile.Open(fn)

                    h = f.Get(root_path)

                    hist.Add(h, 1.0)

                print_hist(hist, args)

        return

    # root file
    if not os.path.isfile(file_path):
        print('%s is not a file' % file_path)
        return 1

    try:
        fin = ROOT.TFile.Open(file_path)

        if fin.IsZombie():
            print('Error opening rootfile')
            fin.Close()
            return 1
    except ReferenceError:
        return 1


    keys = fin.GetListOfKeys()

    if root_path is None:
        for key in keys:
            if args.type:
                print('%s [%s]' % (key.GetName(), key.GetClassName()))
            else:
                print(key.GetName())

    else:

        if args.delete:
            fin.ReOpen('update')
            fin.Delete(root_path+';*')

        elif root_path in [ key.GetName() for key in keys ]:

            obj = fin.Get(root_path)

            # dir
            if obj.InheritsFrom('TDirectory'):
                for key in obj.GetListOfKeys():
                    print(key.GetName())

            # histogram
            elif obj.InheritsFrom('TH1'):
                print_hist(obj, args)

            # tree
            elif obj.InheritsFrom('TTree'):
                print_tree(obj, args)

            elif obj.InheritsFrom('RooWorkspace'):
                obj.Print()


        else:
            print('object %s does not exist' % root_path)


    fin.Close()
    return 0


if __name__ == '__main__':
    main()
